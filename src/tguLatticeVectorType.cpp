/* **********************************************************************
Copyright 2020  Dr. J. C. Shillcock and Prof. Dr. R. Lipowsky, Director at the Max Planck Institute (MPI) of Colloids and Interfaces; Head of Department Theory and Bio-Systems.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
********************************************************************** */
// tguLatticeVectorType.cpp: implementation of the tguLatticeVectorType class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "SimDefs.h"
#include "tguLatticeVectorType.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
// Currently, only real values can be generated by the lattice vector types.
// This constructor handles both 2d and 3d lattices, but the calling routine,
// which may be a dimension-specific lattice class, should set the Y and Z
// parameters appropriately.

tguLatticeVectorType::tguLatticeVectorType(long xmax, long ymax, long zmax,
                                           double ox, double oy, double oz,
                                           double lx, double ly, double lz) : tguArgumentType(0.0),
                                           m_Counter(0)
{
    // Store the protected members of this class; because objects are constructed
    // from the base class up, values written here can be overwritten by derived
    // class constructors. We zero the unit vectors and let the derived classes
    // set their non-zero components.

    for(long i=0; i<3; i++)
    {
        m_e1[i] = 0.0;  
        m_e2[i] = 0.0;
        m_e3[i] = 0.0;
        m_C[i]  = 0;
        m_V[i]  = 0.0;
    }

    m_MaxIndex[0] = xmax;
    m_MaxIndex[1] = ymax;
    m_MaxIndex[2] = zmax;
    m_Origin[0]   = ox;
    m_Origin[1]   = oy;
    m_Origin[2]   = oz;
    m_Length[0]   = lx;
    m_Length[1]   = ly;
    m_Length[2]   = lz;
}

tguLatticeVectorType::~tguLatticeVectorType()
{
}

// Because the tguArgumentType base class demands that we implement GetNextValue() 
// for all types of arguments, we provide do-nothing implementations here.
// The actual values of the lattice vector's components are calculated in the 
// GetComponent() function below.

void tguLatticeVectorType::GetNextValue(long *pValue)
{
}

void tguLatticeVectorType::GetNextValue(double *pValue)
{
}

void tguLatticeVectorType::GetNextValue(zString *pValue)
{
}

// Function to return the index-th component of the next lattice vector.
// Similarly to the GetNextValue() functions, it increments the lattice
// vector first, and then returns the appropriate component. The current
// value can be accessed without incrementing using the protected member
// variable m_V[].
//
// The algorithm we use is the following:
//
// If the desired component is the X component, we calculate
// the new lattice point whose components are the values to assign to the
// arguments. Once we have the new value, we increment the lattice indices
//  and check to see if any of them  have reached the end of their
// lattice dimension and increment the subsequent components. If we reach the
// end of the lattice, then we wrap around to the origin.
//
// The member variable m_Counter is the number of lattice points calculated
// so far NOT the number of component values returned. Hence, we only 
// increment it when the desired component is X. Note that all lattice
// dimensions need an X component, and we just ignore the Y and Z components
// if they are not required. This algorithm only works if the user asks
// for the components in the order X, Y, Z.
// 
// If index is out of range, we return zero; if it is valid, we store
// the component for later recall.

double tguLatticeVectorType::GetNextComponent(long index)
{
    double value = 0.0;

    if(index == 0)  
    {
        ++m_Counter;

        // The first vector points to the origin, subsequent ones
        // depend on the incremented lattice indices

        m_V[0] = m_Origin[0] + (m_C[0]*m_Length[0]*m_e1[0] + 
                                m_C[1]*m_Length[1]*m_e2[0] + 
                                m_C[2]*m_Length[2]*m_e3[0]);

        m_V[1] = m_Origin[1] + (m_C[0]*m_Length[0]*m_e1[1] + 
                                m_C[1]*m_Length[1]*m_e2[1] + 
                                m_C[2]*m_Length[2]*m_e3[1]);

        m_V[2] = m_Origin[2] + (m_C[0]*m_Length[0]*m_e1[2] + 
                                m_C[1]*m_Length[1]*m_e2[2] + 
                                m_C[2]*m_Length[2]*m_e3[2]);

        value = m_V[0];

        // Now increment the lattice indices for the next point

        m_C[0] += 1;

        if(m_C[0] == m_MaxIndex[0])
        {
            m_C[0] = 0;
            m_C[1] += 1;

            if(m_C[1] == m_MaxIndex[1])
            {
                m_C[1] = 0;
                m_C[2] += 1;

                if(m_C[2] == m_MaxIndex[2])
                {
                    m_C[0] = 0;
                    m_C[1] = 0;
                    m_C[2] = 0;
                }
            }
        }
    }
    else if(index == 1 || index == 2)
    {
        value = m_V[index];
    }

    return value;
}
