/* **********************************************************************
Copyright 2020  Dr. J. C. Shillcock and Prof. Dr. R. Lipowsky, Director at the Max Planck Institute (MPI) of Colloids and Interfaces; Head of Department Theory and Bio-Systems.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
********************************************************************** */
// prfActin.cpp: implementation of the prfActin class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "SimDefs.h"
#include "SimMathFlags.h"
#include "SimAlgorithmFlags.h"
#include "SimXMLFlags.h"
#include "prfActin.h"
#include "LogCreateEventFailed.h"
#include "SimState.h"
#include "ISimBox.h"
#include "TimeSeriesData.h"
#include "InputData.h"
#include "aaRegionToType.h"
#include "Slice.h"

// Active Cell Network monitored by the process

#include "aefActinNetwork.h"

// Commands generated by the process

// Commands implementing the IModifyBLMVesicleFusion interface

#include "pcBLMVesicleFusionSetCondenseDelay.h"

// Messages issued as a result of process logic

#include "LogCommandFailed.h"
#include "LogpcBLMVesicleFusionSetCondenseDelay.h"


// STL using declarations


//////////////////////////////////////////////////////////////////////
// Global members
//////////////////////////////////////////////////////////////////////

// Static member variable containing the identifier for this process. 
// The static member function GetType() is invoked by the xxProcessObject 
// to compare the type read from the control data file with each
// xxProcess-derived class so that it can create the appropriate object 
// to hold the process data.
//
// NOTE. For processes attached to ACNs this identifier must be IDENTICAL to
// that in the associated ACN class. We cannot use a call to 
// aefActinNetwork::GetType() to access the ACN's static member because not
// all compilers will initialise the ACN before this class.
	
const zString prfActin::m_Type = "fActin";

const zString prfActin::GetType()
{
	return m_Type;
}

// We use an anonymous namespace to wrap the call to the factory object
// so that it is not accessible from outside this file. The identifying
// string is stored in the m_Type static member variable.
//
// Note that the Create() function is not a member function but a global 
// function hidden in the namespace.
//
// NOTE.
// Because this process is attached to an ACN that is responsible for
// creating it, we use the ACNs string identifier as the key into the
// process map. This avoids a possible disconnection if the ACN and process
// labels are not kept identical.

namespace
{
	xxProcess* Create() {return new prfActin();}

	const zString id = prfActin::GetType();

	const bool bRegistered = acfProcessFactory::Instance()->Register(id, Create);
}

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

// Constructor for use when the acfProcessFactory class creates a process
// according to its string identifier read from the control data file.

prfActin::prfActin() : IModifyfActinProcess(), m_pACN(0),
						m_MonomerTotal(0), m_FreeMonomerTotal(0), m_BoundMonomerTotal(0), m_FilamentTotal(0),
						m_FreeMonomerFraction(0.0), m_BoundMonomerFraction(0.0),
						m_MeanFilamentSize(0.0), m_SDevFilamentSize(0.0),
						m_MeanFilamentLength(0.0), m_SDevFilamentLength(0.0),
                                              m_MeanFilamentLatSqDisp(0.0), m_VarFilamentLatSqDisp(0.0)
{
	for(short int i=0; i<3; i++)
	{
	  m_MeanFilamentSqDisp[i] = 0.0;
	  m_VarFilamentSqDisp[i]  = 0.0;
	  m_MeanFilamentCM[i]     = 0.0;
	  m_MeanFilamentHead[i]   = 0.0;
	  m_MeanFilamentTail[i]   = 0.0;
	  m_VarFilamentCM[i]      = 0.0; 
	  m_VarFilamentHead[i]    = 0.0;
	  m_VarFilamentTail[i]    = 0.0;
	}
}

// Constructor for use by the shadow SimBox so that it can attach the process
// to the ACN allowing it to serialise its data. This constructor cannot be called
// by the acfProcessFactory class and should only be used internally.

prfActin::prfActin(const aefActinNetwork* pACN, long start, long end) : IModifyfActinProcess(), 
                                            m_pACN(pACN),
											m_MonomerTotal(0), m_FreeMonomerTotal(0), m_BoundMonomerTotal(0),
											m_FilamentTotal(0),
											m_FreeMonomerFraction(0.0), m_BoundMonomerFraction(0.0),
											m_MeanFilamentSize(0.0), m_SDevFilamentSize(0.0),
											m_MeanFilamentLength(0.0), m_SDevFilamentLength(0.0),
											m_MeanFilamentLatSqDisp(0.0), m_VarFilamentLatSqDisp(0.0)
{
	// Now that the base class part of this class has been constructed, set the
	// time interval for process analysis. This is for informational purposes
	// in the process state's file only, as the times are not used in the analysis.

	SetStartTime(start);
	SetEndTime(end);

	for(short int i=0; i<3; i++)
	{
	  m_MeanFilamentSqDisp[i] = 0.0;
	  m_VarFilamentSqDisp[i]  = 0.0;
	  m_MeanFilamentCM[i]     = 0.0;
	  m_MeanFilamentHead[i]   = 0.0;
	  m_MeanFilamentTail[i]   = 0.0;
	  m_VarFilamentCM[i]      = 0.0; 
	  m_VarFilamentHead[i]    = 0.0;
	  m_VarFilamentTail[i]    = 0.0;
	}

}

prfActin::~prfActin()
{

}

// Member functions to write/read the data specific to the process.
// The put() function is empty as the base class putASCIIStartTags(), 
// putASCIIEndTags() and their XML equivalents replace its function.

zOutStream& prfActin::put(zOutStream& os) const
{
	return os;
}

zInStream& prfActin::get(zInStream& is)
{
	// Read base class data first

	xxProcess::get(is);

	// No data entry required for this process as it is internal

	return is;
}


// Non-static function to return the type of the process

const zString prfActin::GetProcessType() const
{
	// We return the associated ACN's type so that the ACN and process
	// are guaranteed to return the same string

	return aefActinNetwork::GetType();
}

// Function to return a pointer to a copy of the current process.

xxProcess* prfActin::GetProcess() const
{
	return new prfActin(*this);
}

// Function to update the state of the process using data from the associated
// aggregates (CVesicle) and events (evVesiclePore,...).
//
// This process monitors the aefActinNetwork and outputs analysis of the filament
// growth.
//

void prfActin::UpdateState(CSimState& rSimState, const ISimBox* const pISimBox)
{
	// Obtain the filament analysis data to be output to the process file: 

	m_FreeMonomerTotal		= m_pACN->GetFreeBondTotal();
	m_BoundMonomerTotal		= m_pACN->GetBoundBondTotal();
	m_FreeMonomerFraction	= m_pACN->GetFreeBondFraction();
	m_BoundMonomerFraction	= m_pACN->GetBoundBondFraction();
	m_FilamentTotal			= m_pACN->GetFilamentTotal();
	m_MeanFilamentSize		= m_pACN->GetMeanFilamentSize();
	m_SDevFilamentSize		= m_pACN->GetSDevFilamentSize();
	m_MeanFilamentLength	= m_pACN->GetMeanFilamentLength();
	m_SDevFilamentLength	= m_pACN->GetSDevFilamentLength();
	m_MeanFilamentLatSqDisp = m_pACN->GetMeanLatSqDisp();
	m_VarFilamentLatSqDisp  = m_pACN->GetVarLatSqDisp();

	for(short int i=0; i<3; i++)
	{
	    m_MeanFilamentCM[i]     = m_pACN->GetMeanCM(i);
	    m_MeanFilamentSqDisp[i] = m_pACN->GetMeanSqDisp(i);
	    m_VarFilamentSqDisp[i]  = m_pACN->GetVarSqDisp(i);
		m_MeanFilamentHead[i]   = m_pACN->GetMeanHeadCoord(i);
		m_MeanFilamentTail[i]   = m_pACN->GetMeanTailCoord(i);
		m_VarFilamentHead[i]    = m_pACN->GetVarHeadCoord(i);
		m_VarFilamentTail[i]    = m_pACN->GetVarTailCoord(i);
	}

	const long fixedDataTotal = 21;

    // Note that the number of events is not known a priori, but each event
    // has a success and a failure counter.

// Event data removed for now 08/09/2006

//    long dataTotal = fixedDataTotal + 2*m_pACN->GetEventTotal();
    long dataTotal = fixedDataTotal;

	CTimeSeriesData* const pTSD = new CTimeSeriesData(dataTotal);

	pTSD->SetValue(0,  pISimBox->GetCurrentTime(), "Time");
	pTSD->SetValue(1,  m_FreeMonomerTotal,		"FreeMonomerTotal");
	pTSD->SetValue(2,  m_BoundMonomerTotal,		"BoundMonomerTotal");
	pTSD->SetValue(3,  m_FreeMonomerFraction,	"FreeMonomerFraction");
	pTSD->SetValue(4,  m_BoundMonomerFraction,	"BoundMonomerFraction");
	pTSD->SetValue(5,  m_FilamentTotal,			"FilamentTotal");
	pTSD->SetValue(6,  m_MeanFilamentSize,		"MeanFilamentSize");
	pTSD->SetValue(7,  m_SDevFilamentSize,		"SDevFilamentSize");
	pTSD->SetValue(8,  m_MeanFilamentLength,	"MeanFilamentLength");
	pTSD->SetValue(9,  m_SDevFilamentLength,	"SDevFilamentLength");
	pTSD->SetValue(10, m_MeanFilamentLatSqDisp,	"MeanFilamentLatSqDisp");
	pTSD->SetValue(11, m_VarFilamentLatSqDisp,	"VarFilamentLatSqDisp");
	pTSD->SetValue(12, m_MeanFilamentCM[0],	    "MeanFilamentCMX");
	pTSD->SetValue(13, m_MeanFilamentSqDisp[0],	"MeanFilamentSqDispX");
	pTSD->SetValue(14, m_VarFilamentSqDisp[0],	"VarFilamentSqDispX");
	pTSD->SetValue(15, m_MeanFilamentCM[1],	    "MeanFilamentCMY");
	pTSD->SetValue(16, m_MeanFilamentSqDisp[1],	"MeanFilamentSqDispY");
	pTSD->SetValue(17, m_VarFilamentSqDisp[1],	"VarFilamentSqDispY");
	pTSD->SetValue(18, m_MeanFilamentCM[2],	    "MeanFilamentCMZ");
	pTSD->SetValue(19, m_MeanFilamentSqDisp[2],	"MeanFilamentSqDispZ");
	pTSD->SetValue(20, m_VarFilamentSqDisp[2],	"VarFilamentSqDispZ");

    // Now the ACN's event data: for now we just count the bond binding events.
    // Note that the number of events must be even or the loop will fail. This
    // works for bond binding events as they always occur in pairs (bond on and
    // bond off).

 //   std::cout << "Bond stats for filament of size: " << m_MeanFilamentSize << zEndl;
 //   for(long j=0; j<m_pACN->GetEventTotal(); j++)
 //   {
 //       std::cout << m_pACN->GetEventSuccessCounter(j) << " " << m_pACN->GetEventFailureCounter(j) << zEndl;
 
 //       pTSD->SetValue(fixedDataTotal+2*j,   m_pACN->GetEventSuccessCounter(j), "EventSuccessCounter");
 //       pTSD->SetValue(fixedDataTotal+2*j+1, m_pACN->GetEventFailureCounter(j), "EventFailureCounter");
 //   }

	m_pState->AddTimeSeriesData(pTSD);
}

// Function to check that the user-specified data is valid and. As this process
// is internally generated by the shadow SimBox we do not perform validity checking.

bool prfActin::ValidateData(const CInputData &riData)
{
	return false;
}

// Function to check that the data for a process that is internally generated
// is valid, and to create the xxProcessState to serialise the data to file.

bool prfActin::InternalValidateData(const ISimState* const pISimState)
{
	// An xxProcessState is created to hold the data that the process wants
	// to write to file. Data is passed as a series of CTimeSeriesData objects
	// as used for CHistoryState. Because this function is called after the
	// original xxProcess instance is copied (so that the xxProcessObject instance
	// can be discarded), creating the xxAggregateState here does not result in
	// it being destroyed. Hence, we can write the XML opening tags to the file safely.

	// The process state's file name depends on whether it is XML-enabled or not,
	// so we use two different SetState() signatures to allow for this. If it
	// is XML-enabled, we write out the standard processing instructions and
	// wrapper tags <ProcessState></ProcessState> as the first and last elements 
	// in the file. Because the process state can write data until the simulation 
	// ends, we only write the end tag in the base class's destructor.

#if EnableXMLProcesses == SimXMLEnabled

	SetState(new xxProcessState(xxBase::GetPSPrefix() + GetProcessType() + ToString(GetId()) + "." + pISimState->GetRunId() + ".xml", GetStartTime(), GetEndTime(), pISimState->GetRunId(), GetProcessType()));

	// Note that the opening <Header> tag is written in the xxProcessState class
	// but the closing tag is written here. This is a hack.

	zOutStream& os = m_pState->putXMLStartTags();
//	os << "<MonomerTotal>"		<< m_MonomerTotal		<< "</MonomerTotal>"	<< zEndl;
	os << "</Header>" << zEndl;

#elif EnableXMLProcesses == SimXMLDisabled

	SetState(new xxProcessState(xxBase::GetPSPrefix() + GetProcessType() + ToString(GetId()) + "." + pISimState->GetRunId(), GetStartTime(), GetEndTime(), pISimState->GetRunId(), GetProcessType()));

	m_pState->putASCIIStartTags();
//	zOutStream& os = m_pState->putASCIIStartTags();
//	os << "    MonomerTotal		" << m_MonomerTotal	 << zEndl;

#endif

	return true;
}

// Function used by the associated ACN to connect itself to the process so that
// it can serialise its data to file.

void prfActin::SetACN(const aefActinNetwork* pACN)
{
	m_pACN = pACN;
}

// ****************************************
// Forwarding functions to the base class' implementation of IModifyProcess interface

bool prfActin::IsModifiable() const
{
	return InternalIsModifiable();
}

void prfActin::SetModifiable(const xxCommand* const pCommand)
{
	return InternalSetModifiable(pCommand);
}

void prfActin::SetUnmodifiable(const xxCommand* const pCommand)
{
	return InternalSetUnmodifiable(pCommand);
}

// Function to allow the process to prevent any further modifications to itself.
// Note that a warning is logged if this command is sent more than once to the
// same process.

void prfActin::SetIrreversibleUnmodifiable(const xxCommand* const pCommand)
{	
	return InternalSetIrreversibleUnmodifiable(pCommand);
}

// ****************************************
// Implementation of IModifyfActin interface

void prfActin::SetCondenseDelay(const xxCommand* const pCommand)
{
	const pcBLMVesicleFusionSetCondenseDelay* const pCmd = dynamic_cast<const pcBLMVesicleFusionSetCondenseDelay*>(pCommand);

	const zString pid = pCmd->GetPid();
	const long  delay = pCmd->GetDelay();
	
	if(pid == GetPid() && IsModifiable() && delay >= 0)
	{
		m_CondenseDelay = delay;

		std::cout << "setting condense delay to " << delay << zEndl;

		 new CLogpcBLMVesicleFusionSetCondenseDelay(pCmd->GetExecutionTime(), pid, delay);

	}
	else
	{
		 new CLogCommandFailed(pCmd->GetExecutionTime(), pCmd);
	}
}

