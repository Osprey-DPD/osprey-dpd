/* **********************************************************************
Copyright 2020  Dr. J. C. Shillcock and Prof. Dr. R. Lipowsky, Director at the Max Planck Institute (MPI) of Colloids and Interfaces; Head of Department Theory and Bio-Systems.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
********************************************************************** */
// prBeadDensityFluctuations.cpp: implementation of the prBeadDensityFluctuations class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "SimDefs.h"
#include "SimMathFlags.h"
#include "SimAlgorithmFlags.h"
#include "SimXMLFlags.h"
#include "prBeadDensityFluctuations.h"
#include "IGlobalSimBox.h"
#include "SimState.h"
#include "ISimBox.h"
#include "Monitor.h"
#include "Bead.h"
#include "TimeSeriesData.h"
#include "InputData.h"
#include "DensityState.h"

// Commands generated by the process



// STL using declarations


//////////////////////////////////////////////////////////////////////
// Global members
//////////////////////////////////////////////////////////////////////

// Static member variable containing the identifier for this process. 
// The static member function GetType() is invoked by the xxProcessObject 
// to compare the type read from the control data file with each
// xxProcess-derived class so that it can create the appropriate object 
// to hold the process data.
//
    
const zString prBeadDensityFluctuations::m_Type = "BeadDensityFluctuations";

const zString prBeadDensityFluctuations::GetType()
{
	return m_Type;
}

// We use an anonymous namespace to wrap the call to the factory object
// so that it is not accessible from outside this file. The identifying
// string is stored in the m_Type static member variable.
//
// Note that the Create() function is not a member function but a global 
// function hidden in the namespace.

namespace
{
	xxProcess* Create() {return new prBeadDensityFluctuations();}

	const zString id = prBeadDensityFluctuations::GetType();

	const bool bRegistered = acfProcessFactory::Instance()->Register(id, Create);
}

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

// Default constructor

prBeadDensityFluctuations::prBeadDensityFluctuations() : m_BeadName(""),
                              m_BeadType(0),
                              m_TotalDataPoints(0),
                              m_TotalDensityPeriods(0),
                              m_XCellNo(0), m_YCellNo(0), m_ZCellNo(0),
                              m_bConjugate(true),
                              m_SamplePeriod(0),
                              m_DensityPeriod(0),
                              m_SamplesTaken(0), m_SamplesPerDataPoint(0),
                              m_BeadTotal(0),
                              m_GridXCellNo(0), m_GridYCellNo(0), m_GridZCellNo(0), 
                              m_RunningMeanInCell(0.0), m_RunningSDevInCell(0.0),
                              m_RunningMeanOutsideCell(0.0), m_RunningSDevOutsideCell(0.0)
{
}

// Constructor for use when the process is created by command. Default values for
// all required parameters must be passed to this constructor. We do NOT check that
// the analysis performed by this process can be completed during the run. If the 
// context within which this process operates becomes invalid, the process terminates and 
// logs an error message to the log file.

prBeadDensityFluctuations::prBeadDensityFluctuations(const CSimState* const pSimState, 
                              long beadType, long dataPoints, long densityPeriods, 
                              long xCell, long yCell, long zCell, bool bConjugate) : m_BeadName(pSimState->cGetAnalysisState().GetBeadNameFromType(beadType)),
                              m_BeadType(beadType),
                              m_TotalDataPoints(dataPoints),
                              m_TotalDensityPeriods(densityPeriods),
                              m_XCellNo(xCell), m_YCellNo(yCell), m_ZCellNo(zCell),
                              m_bConjugate(bConjugate),
                              m_SamplePeriod(pSimState->GetSamplePeriod()),
                              m_DensityPeriod(pSimState->GetDensityPeriod()),
                              m_SamplesTaken(0), m_SamplesPerDataPoint(0),
                              m_BeadTotal(pSimState->cGetInitialState().GetBeadTotalForType(beadType)),
                              m_GridXCellNo(pSimState->GetGridXCellNo()), 
                              m_GridYCellNo(pSimState->GetGridYCellNo()), 
                              m_GridZCellNo(pSimState->GetGridZCellNo()), 
                              m_RunningMeanInCell(0.0), m_RunningSDevInCell(0.0),
                              m_RunningMeanOutsideCell(0.0), m_RunningSDevOutsideCell(0.0)

{
    // Set the times at which the process' analysis will be performed. This is
    // defined to be the time from the start of the next full density period as
    // defined in the CMonitor until the end of the number of such periods given 
    // by m_TotalDensityPeriods*m_TotalDataPoints, or the end of the simulation
    // whichever comes first.
    // Note that the bead density fields are constructed by sampling every 
    // m_SamplePeriod time steps for densityPeriod steps. This gives one average of
    // the density fields. We then average these values over TotalDensityPeriods 
    // and construct the cell's mean occupation number. Finally, a total of 
    // m_TotalDataPoints such means are output to the file.

    long currentTime      = IGlobalSimBox::Instance()->GetCurrentTime();
    long duration         = m_TotalDataPoints*m_TotalDensityPeriods*m_DensityPeriod;
    long samples          = duration/m_SamplePeriod;
    m_SamplesPerDataPoint = samples/m_TotalDataPoints;

    long start = 0;
    long end   = 0;

    if(currentTime%m_DensityPeriod == 0)
    {
        start = currentTime;
    }
    else
    {
        start = (currentTime/m_DensityPeriod + 1)*m_DensityPeriod;
    }

    end = start + duration;

    // Check that the simulation is long enough to allow this many samples and,
    // if not, reduce the number of samples so that a whole number fit into 
    // the remaining simulation time.

    if(end > IGlobalSimBox::Instance()->GetTotalTime())
    {
        duration = IGlobalSimBox::Instance()->GetTotalTime() - start;
        m_TotalDataPoints = duration/(m_TotalDensityPeriods*m_DensityPeriod);
        duration = m_TotalDataPoints*m_TotalDensityPeriods*m_DensityPeriod;
        end = start + duration;
    }

	SetStartTime(start);
	SetEndTime(end);
}

prBeadDensityFluctuations::~prBeadDensityFluctuations()
{

}

// Member functions to write/read the data specific to the process.
// The put() function is empty as the base class putASCIIStartTags(), 
// putASCIIEndTags() and their XML equivalents replace its function.

zOutStream& prBeadDensityFluctuations::put(zOutStream& os) const
{
	return os;
}

zInStream& prBeadDensityFluctuations::get(zInStream& is)
{
	// Read base class data first

	xxProcess::get(is);

	// No data entry required for this process as it is internal

	return is;
}


// Non-static function to return the type of the process

const zString prBeadDensityFluctuations::GetProcessType() const
{
	// We return the associated ACN's type so that the ACN and process
	// are guaranteed to return the same string

	return prBeadDensityFluctuations::GetType();
}

// Function to return a pointer to a copy of the current process.

xxProcess* prBeadDensityFluctuations::GetProcess() const
{
	return new prBeadDensityFluctuations(*this);
}

// Function to update the state of the process from the bead data stored in the
// CSimState. It is called every m_SamplePeriod time steps to collect data,
// but only samples data whenever a new density field data point has been created,
// which is every DensityPeriod steps. Then it constructs the average of 
// m_TotalDensityPeriod such data points and outputs them to file. It resets the
// data and starts again with the next density field sample. A total of
// m_TotalDataPoint such samples are output (or the simulation ends before this number
// have been output.)
// This process assumes that the bead density grid analysis has been turned on 
// by command.

void prBeadDensityFluctuations::UpdateState(CSimState& rSimState, const ISimBox* const pISimBox)
{

    if(m_SamplesTaken == 0) // First call to this function
    {
        m_RunningMeanInCell      = 0.0;
        m_RunningSDevInCell      = 0.0;
        m_RunningMeanOutsideCell = 0.0;
        m_RunningSDevOutsideCell = 0.0;
    }

    // Add a new sample at each multiple of the m_DensityPeriod

    if(pISimBox->GetCurrentTime() % m_DensityPeriod == 0 && pISimBox->GetCurrentTime() > GetStartTime())
    {
       m_SamplesTaken++;
//       std::cout << "adding a sample at time " << pISimBox->GetCurrentTime() << zEndl;


       // Get hold of the latest density state written by the Monitor for the 
       // specified bead type, and extract the number of beads in the specified cell. Note that
       // it is imperative that the Monitor calculate the new density state
       // before this process tries to extract it. Because there can be an arbitrary
       // number of density states (corresponding to each bead type defined in 
       // the simulation), we iterate over them until we find the one with 
       // the specified bead type. We don't search on the bead name as there could
       // be several with the same "Unnamed" string identifiers. However, their
       // numeric identifiers are guaranteed to be unique.
       // Note that the density state container is always created in the Monitor,
       // even if the user does not specify that grid analysis should be performed.
       // But it can therefore be empty. This process should not be created if
       // the bead grid analysis has not been enabled.

       bool   bNotFound   = true;
       long   time        = 0;
       double density     = 0.0;
       double sum         = 0.0;
	   CDensityState* pDS = 0;

       const DensityStateSequence& rDensityStates = pISimBox->GetMonitor()->GetDensityStates();

       crDensityStateIterator iterDS=rDensityStates.rbegin(); 

       while(bNotFound && iterDS!=rDensityStates.rend())
       {
		    pDS = *iterDS;

            if(pDS->GetFieldId() == m_BeadType)
            {
                bNotFound = false;
            }
            else
            {
                iterDS++;
            }
       }

       if(!bNotFound && pDS)
       {
           sum     = pDS->GetSum(m_XCellNo, m_YCellNo, m_ZCellNo);

           time    = pDS->GetCurrentTime();
           density = pDS->GetDensity(m_XCellNo, m_YCellNo, m_ZCellNo);
//           std::cout << "sampling density state for bead type " << pDS->GetFieldName() << " " << pDS->GetFieldId() << " at time = " << time << "  " << density << "  " << sum << zEndl;
 
           m_RunningMeanInCell += sum;
           m_RunningSDevInCell += sum*sum;

           if(m_bConjugate)
           {
               m_RunningMeanOutsideCell += (m_BeadTotal - sum);
               m_RunningSDevOutsideCell += (m_BeadTotal - sum)*(m_BeadTotal - sum);
           }


           // When m_TotalDensityPeriods samples have been taken, normalise
           // the observables and write them to the process state file.

           if(m_SamplesTaken == m_TotalDensityPeriods)
           {
//               std::cout << "Normalising " << m_SamplesTaken << " samples at time " << pISimBox->GetCurrentTime() << zEndl;
//               std::cout << "Check on no of samples: " << m_TotalDensityPeriods << zEndl;
               m_SamplesTaken = 0;
               m_RunningMeanInCell /= static_cast<double>(m_TotalDensityPeriods);
               m_RunningSDevInCell /= static_cast<double>(m_TotalDensityPeriods);
               m_RunningSDevInCell = m_RunningSDevInCell - m_RunningMeanInCell*m_RunningMeanInCell;

                if(m_bConjugate)
                {
                    // Data is: time, mean, sdev for beads in cell and outside cell
                    m_RunningMeanOutsideCell /= static_cast<double>(m_TotalDensityPeriods);
                    m_RunningSDevOutsideCell /= static_cast<double>(m_TotalDensityPeriods);
                    m_RunningSDevOutsideCell = m_RunningSDevOutsideCell - m_RunningMeanOutsideCell*m_RunningMeanOutsideCell;

                    CTimeSeriesData* const pTSD = new CTimeSeriesData(5);
                    pTSD->SetValue(0,  pISimBox->GetCurrentTime(), "Time");
                    pTSD->SetValue(1,  m_RunningMeanInCell, "MeanInCell");
                    pTSD->SetValue(2,  m_RunningSDevInCell, "SDevInCell");
                    pTSD->SetValue(3,  m_RunningMeanOutsideCell, "MeanOutsideCell");
                    pTSD->SetValue(4,  m_RunningSDevOutsideCell, "SDevOutsideCell");

                    m_pState->AddTimeSeriesData(pTSD);         
                }
                else
                {
                    // Data is: time, mean, sdev for beads in cell only

                    CTimeSeriesData* const pTSD = new CTimeSeriesData(3);
                    pTSD->SetValue(0,  pISimBox->GetCurrentTime(), "Time");
                    pTSD->SetValue(1,  m_RunningMeanInCell, "MeanInCell");
                    pTSD->SetValue(2,  m_RunningSDevInCell, "SDevInCell");

                    m_pState->AddTimeSeriesData(pTSD);
                }
            }
       }
    }
}

// Function to check that the user-specified data is valid and. As this process
// is internally generated by the shadow SimBox we do not perform validity checking.

bool prBeadDensityFluctuations::ValidateData(const CInputData &riData)
{
	return false;
}

// Function to check that the data for a process that is internally generated
// is valid, and to create the xxProcessState to serialise the data to file.

bool prBeadDensityFluctuations::InternalValidateData(const ISimState* const pISimState)
{
	// An xxProcessState is created to hold the data that the process wants
	// to write to file. Data is passed as a series of CTimeSeriesData objects
	// as used for CHistoryState. Because this function is called after the
	// original xxProcess instance is copied (so that the xxProcessObject instance
	// can be discarded), creating the xxAggregateState here does not result in
	// it being destroyed. Hence, we can write the XML opening tags to the file safely.

	// The process state's file name depends on whether it is XML-enabled or not,
	// so we use two different SetState() signatures to allow for this. If it
	// is XML-enabled, we write out the standard processing instructions and
	// wrapper tags <ProcessState></ProcessState> as the first and last elements 
	// in the file. Because the process state can write data until the simulation 
	// ends, we only write the end tag in the base class's destructor.

#if EnableXMLProcesses == SimXMLEnabled

	SetState(new xxProcessState(xxBase::GetPSPrefix() + GetProcessType() + ToString(GetId()) + "." + m_BeadName + "." + pISimState->GetRunId() + ".xml", GetStartTime(), GetEndTime(), pISimState->GetRunId(), GetProcessType()));

	// Note that the opening <Header> tag is written in the xxProcessState class
	// but the closing tag is written here. This is a hack.

	zOutStream& os = m_pState->putXMLStartTags();
	os << "<BeadName>"            << m_BeadName << "</BeadName>" << zEndl;
	os << "<BeadType>"            << m_BeadType << "</BeadType>" << zEndl;
	os << "<TotalDataPoints>"     << m_TotalDataPoints << "</TotalDataPoints>" << zEndl;
	os << "<TotalDensityPeriods>" << m_TotalDensityPeriods << "</TotalDensityPeriods>" << zEndl;
	os << "<XCellNo>"             << m_XCellNo << "</XCellNo>";
	os << "<YCellNo>"             << m_YCellNo << "</YCellNo>";
	os << "<ZCellNo>"             << m_ZCellNo << "</ZCellNo>"<< zEndl;
	os << "<GridXCellNo>"         << m_GridXCellNo << "</GridXCellNo>";
	os << "<GridYCellNo>"         << m_GridYCellNo << "</GridYCellNo>";
	os << "<GridZCellNo>"         << m_GridZCellNo << "</GridZCellNo>" << zEndl;
	os << "<ConjugateFlag>"       << m_bConjugate << "</ConjugateFlag>" << zEndl;
	os << "</Header>" << zEndl;

#elif EnableXMLProcesses == SimXMLDisabled

	SetState(new xxProcessState(xxBase::GetPSPrefix() + GetProcessType() + ToString(GetId()) + "." + m_BeadName + "." + pISimState->GetRunId(), GetStartTime(), GetEndTime(), pISimState->GetRunId(), GetProcessType()));

	zOutStream& os = m_pState->putASCIIStartTags();
	os << "    BeadName            " << m_BeadName << zEndl;
	os << "    BeadType            " << m_BeadType << zEndl;
	os << "    TotalDataPoints     " << m_TotalDataPoints << zEndl;
	os << "    TotalDensityPeriods " << m_TotalDensityPeriods << zEndl;
	os << "    Grid Cell Indices   " << m_XCellNo << " " << m_YCellNo << " " << m_ZCellNo << zEndl;
	os << "    Grid Cell No        " << m_GridXCellNo << " " << m_GridYCellNo  << " " << m_GridZCellNo << zEndl;
    os << "    Conjugate flag      " << m_bConjugate << zEndl;

#endif

	return true;
}

